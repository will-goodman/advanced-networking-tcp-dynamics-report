\documentclass[12pt]{article}
\rmfamily
\usepackage[margin=1.0in]{geometry}
\usepackage{graphicx}
\graphicspath{ {figures/} }

\title{TCP Dynamics Report}
\date{November 2020}
\author{Will Goodman}

\begin{document}
\maketitle

\section{Analysing the strategy of the client and server to maintain throughput on ports 4030 through 4039}
\subsection*{Investigation}
The data for this part was collected during the between 8PM and 11PM on the evening of Sunday 1st November.

\subsubsection*{Low loss, small file (Port 4032, 256KB)}
To begin investigating the strategy of the client and server, I analysed how a 256KB file was downloaded from port 4032 (10\% packet loss).
From this I identified that the window size was 64240, with the client sending a cumulative acknowledgement after receiving two packets.
I also identified that each TCP packet payload was 1452 bytes, and the sequence number of a packet is the cumulative number of bytes including that packet.
Finally, I noticed that the cumulative acknowledgements asked for the sequence number of the next packet which is required to be sent, not the sequence number of the most up-to-date packet.

Initial analysis of the throughput reveals "plateaus" where no data is being transfered, see figure \ref{figure1: 4032:256KB Throughput}.

\begin{figure}[!htbp]
  \centering
  \includegraphics[scale=0.3]{4032_256KB_throughput-marked-points.jpg}
  \caption{"256KB file, port 4032 (10\%) packet loss throughput."}
  \label{figure1: 4032:256KB Throughput}
\end{figure}

Upon reviewing the packet capture, we can see that the throughput has a slight reduction when the first duplicate ACK is sent (packet 21734 in \ref{figure2: first duplicate ACK} is point A in \ref{figure1: 4032:256KB Throughput}).
Following the first duplicate ACK, it appears the server continues to send packets for 25 milliseconds before resending the missing packet.
This is because the packets are already en-route and the server has not received the duplicate ACK yet. 
From this we can assume that the server is not waiting for an ACK before sending the next packets, and hence is "pipelining" packets.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-256KB-duplicate-ack.PNG}
  \caption{"First duplicate ACK."}
  \label{figure2: first duplicate ACK}
\end{figure}

Once it has resent the missing packet, the server continues where it left off and continues sending packets it has not already sent.
This is seen in figure \ref{figure3: First retransmission}, where the server transmits 169885, then retransmits 108901.
Retransmission of 108901 is point C in figure \ref{figure1: 4032:256KB Throughput}
This first packet the server sends after the retransmission is 171337, which is the next in the sequence (169885 + 1452 = 171337).
This shows that the server knows the client is buffering all out-of-order packets, and is not discarding them like a pipelined receiver.
It also shows that when the timer expires, the server only resends the oldest unacked packet, not all unacked packets as we may expect with a pipelined sender.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-256KB-retransmission.PNG}
  \caption{"First retransmission."}
  \label{figure3: First retransmission}
\end{figure}

By looking at the time taken between the client sending the oldest ACK for the first time, and when the retransmission is received, we can estimate the timeout for unacked packets on the server.
In figure \ref{figure2: first duplicate ACK} line 217032 (ACK) is at 0.756461 seconds and in figure \ref{figure3: First retransmission} line 217113 (retransmission) is at 1.015436 seconds.
This is a time difference of 0.258975.
Later in the TCP trace another packet goes missing, and the time difference is 0.250174.
From these two values we can estimate that the timeout for the oldest unacked packet on the server is a quarter of a second, at which point the server retransmits that packet.

In this case something interesting happens.
It appears a second packet had actually gone missing (114709), and so the client sends another duplicate ACK.
On the server, this appears to trigger a Rapid Recovery/Fast Retransmission as the server starts retransmitting every packet after 114709 (see figure \ref{figure4: Fast retransmission}).

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-256KB-fast-retransmission.PNG}
  \caption{"Fast retransmission."}
  \label{figure4: Fast retransmission}
\end{figure}

As a cumulative acknowledgement is being used, the server only knows that every packet up to 114709 has been received, it does not know the status of every packet it has sent since.
Due to this, the server assumes none of the packets after 114709 have been received, and starts to resend all of them.
In this case, only four packets went missing (108901, 114709, 116161, 117613), and so every packet after this has already been received and buffered (causing a spurious retransmission).
Eventually, the server receives one of the client's duplicate ACKs stating that all of these packets have already been received, and the server starts sending packets as normal (figure \ref{figure5: Return to normal}, and point D on \ref{figure1: 4032:256KB Throughput}).

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-256KB-back-to-normal.PNG}
  \caption{"Return to normal."}
  \label{figure5: Return to normal}
\end{figure}

\subsubsection*{Low loss, medium file (Port 4032, 16MB)}
With a larger file, we begin to see how both the client and server deal with packet loss over a longer period of time.
By reviewing the Stevens Time Sequence, we can clearly see that Slow Start is being used. 
This is not surprising as it is compulsory under the TCP specification.

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-16M-stevens.jpeg}
  \caption{"16MB file, port 4032 (10\%) packet loss stevens."}
  \label{figure6: 4032:16M Stevens}
\end{figure}

By looking at the packet capture, we can see that the same behaviour of acknowledgements and retransmissions occurs for the larger file as it did for the smaller file.
The Window size advertised by the client is large (64240 Bytes) and the buffer never fills up, and as such we never see if Silly Window Syndrome occurs.
This does show however, that Silly Window Syndrome is not as much of an issue today with faster processing power and larger memory.

This 16Mb file never actually finished downloading, the client ended the connection before it completed (figure \ref{figure7: 4032:16M RST}).

\begin{figure}[!htbp]
  \centering
  \includegraphics[width=\linewidth]{4032-16M-RST.PNG}
  \caption{"Client RST."}
  \label{figure7: 4032:16M RST}
\end{figure}

Upon further inspection we can see the last contact from the server (234852) is at 384.979104 seconds.
60 seconds later (235227), the client sends a FIN, ACK packet to close the connection.
This is triggered by the timeout within the Python script used to collect the data (shown at the start of the report).
After this FIN, ACK packet, the client receives a regular packet from the server. 
This packet was likely already in the wire when the FIN, ACK was received by the server.
Due to this, the client sends a RST, ACK packet to terminate the connection completely.

\subsection*{Client/Server Strategy}
\subsubsection*{Client}
Following the investigation, I believe this is the Client's strategy to attempt to maintain throughput:
\begin{itemize}
  \item Send a cumulative ACK after receiving every two packets
  \item If an out-of-order packet is received, an ACK is sent stating what the next expected packet is
  \item If another out-of-order packet is received, a duplicate ACK is sent. This repeats until the missing packet is received
  \item All out-of-order packets are buffered
  \item If a duplicate packet is received, then a duplicate ACK is sent
  \item When the last packet arrives, send a FIN, ACK to close the connection
  \item If no packets from the server for 60 seconds, send a FIN, ACK to close the connection
  \item If any packets are received from the server after sending a FIN, ACK (excluding an acknowledgement of the FIN, ACK), send a RST, ACK packet
\end{itemize}

\subsubsection*{Server}
The server knows less about which packets have been received correctly than the client, so it has a slightly more complicated strategy.
\begin{itemize}
  \item Send packets in order, pipelining packets without waiting for acknowledgement
  \item Use Slow Start (compulsory), if a packet has to be resent then start again
  \item If a packet has not been acknowledged after quarter of a second, just resend that packet. Assume all packets sent since that packet have arrived correctly and pick up where you left off after it is resent
  \item If you receive an ACK for a packet sent after the original lost packet, assume all packets from that sequence number on have been lost and resend them all (Rapid Recovery)
  \item If you receive a duplicate ACK from the client stating that more packets have been arrived than previously thought, stop resending packets before that sequence number and start sending subsequent packets
  \item If you receive a FIN, ACK from the client, as all packets have been received correctly (or the client wants to stop the connection for another reason)
\end{itemize}

\end{document}